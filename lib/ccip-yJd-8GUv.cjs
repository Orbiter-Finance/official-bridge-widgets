"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("./index-CfB50z-k.cjs");class w extends e.BaseError{constructor({callbackSelector:s,cause:t,data:n,extraData:c,sender:i,urls:r}){super(t.shortMessage||"An error occurred while fetching for an offchain result.",{cause:t,metaMessages:[...t.metaMessages||[],t.metaMessages?.length?"":[],"Offchain Gateway Call:",r&&["  Gateway URL(s):",...r.map(u=>`    ${e.getUrl(u)}`)],`  Sender: ${i}`,`  Data: ${n}`,`  Callback selector: ${s}`,`  Extra data: ${c}`].flat(),name:"OffchainLookupError"})}}class k extends e.BaseError{constructor({result:s,url:t}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:[`Gateway URL: ${e.getUrl(t)}`,`Response: ${e.stringify(s)}`],name:"OffchainLookupResponseMalformedError"})}}class b extends e.BaseError{constructor({sender:s,to:t}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:[`Contract address: ${t}`,`OffchainLookup sender address: ${s}`],name:"OffchainLookupSenderMismatchError"})}}const L="0x556f1830",y={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function E(d,{blockNumber:s,blockTag:t,data:n,to:c}){const{args:i}=e.decodeErrorResult({data:n,abi:[y]}),[r,u,f,a,o]=i,{ccipRead:l}=d,h=l&&typeof l?.request=="function"?l.request:m;try{if(!e.isAddressEqual(c,r))throw new b({sender:r,to:c});const p=u.includes(e.localBatchGatewayUrl)?await e.localBatchGatewayRequest({data:f,ccipRequest:h}):await h({data:f,sender:r,urls:u}),{data:g}=await e.call(d,{blockNumber:s,blockTag:t,data:e.concat([a,e.encodeAbiParameters([{type:"bytes"},{type:"bytes"}],[p,o])]),to:c});return g}catch(p){throw new w({callbackSelector:a,cause:p,data:n,extraData:o,sender:r,urls:u})}}async function m({data:d,sender:s,urls:t}){let n=new Error("An unknown error occurred.");for(let c=0;c<t.length;c++){const i=t[c],r=i.includes("{data}")?"GET":"POST",u=r==="POST"?{data:d,sender:s}:void 0,f=r==="POST"?{"Content-Type":"application/json"}:{};try{const a=await fetch(i.replace("{sender}",s.toLowerCase()).replace("{data}",d),{body:JSON.stringify(u),headers:f,method:r});let o;if(a.headers.get("Content-Type")?.startsWith("application/json")?o=(await a.json()).data:o=await a.text(),!a.ok){n=new e.HttpRequestError({body:u,details:o?.error?e.stringify(o.error):a.statusText,headers:a.headers,status:a.status,url:i});continue}if(!e.isHex(o)){n=new k({result:o,url:i});continue}return o}catch(a){n=new e.HttpRequestError({body:u,details:a.message,url:i})}}throw n}exports.ccipRequest=m;exports.offchainLookup=E;exports.offchainLookupAbiItem=y;exports.offchainLookupSignature=L;
